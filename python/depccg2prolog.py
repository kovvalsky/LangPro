#!/usr/bin/env python3
# -*- coding: utf8 -*-

'''
Convert decppcg derivations in json format into prolog ccg derivations
'''

import os
import sys
import argparse
import re
from collections import Counter, defaultdict
import json


#################################
def parse_arguments():
    '''Read arguments from a command line'''
    parser = argparse.ArgumentParser(description='Convert depccg derivation into prolog')
    parser.add_argument(
    'der', metavar='PATH',
        help='Json file containing depccg derivations')
    parser.add_argument(
    'output', metavar='PATH',
        help='File for writing prolog derivations')
    parser.add_argument(
    '--anno', required=True, metavar='PATH',
        help='Annotation file including token|pos|ner tags')
    parser.add_argument(
    '--lemma', required=True, metavar='PATH',
        help='File with lemmatized tokens')
    parser.add_argument(
    '--ids', metavar='ID LIST', nargs='+', type=int,
        help='Process only the specific entries')
    parser.add_argument(
    '-v', '--verbose', dest='v', default=0, action='count',
        help='Verbosity level of reporting')
    args = parser.parse_args()
    return args


def check_der_anno(der, anno, v=0):
    '''Check that derivation and annotations are for the same token list
    '''
    toks = re.findall('"word": "([^"]+)"', json.dumps(der))
    if len(toks) != len(anno):
        raise ValueError("{} =\= {}".format(len(toks), len(anno)))
    for t, a in zip(toks, anno):
        w = a.split('|', 1)[0]
        if w != t:
            raise ValueError("{} =\= {} in {}".format(w, t, anno))


#################################
def derdict_anno2pl(der, anno, lemma, v=0):
    '''Combine derivation and annotations and convert into prolog ccg format
    '''
    check_der_anno(der, anno, v=v)
    _, pl, a_rest, l_rest = der_anno_to_pl(der, anno, lemma, lvl=1)
    if a_rest or l_rest:
        raise ValueError("{} is not empaty".format(a_rest + l_rest))
    return pl

#################################
def cat2pl(cat, v=0):
    '''Convert category into prolog syntax
    '''
    cat = cat.lower().replace('\\\\', '\\')
    cat = re.sub('\[([^]]+)\]', r':\1', cat)
    return cat

#################################
def der_anno_to_pl(der, anno, lemma, lvl=0):
    '''Recursively reads a tree encoded as dict and aligns it with annotations
    '''
    # format the category for prolog
    cat = cat2pl(der['cat'])
    cat_pl = cat # category that is printed in ccg prolog,
                 # it can be augmented with child category for lex and conj combinators
    if 'children' in der:
        assert 3 > len(der['children']) > 0, "Inconsistent number of children {}".format(der)
        children_pl = ''
        children_cats = []
        for ch in der['children']:
            ch_cat, pl, anno, lemma = der_anno_to_pl(ch, anno, lemma, lvl=lvl+1)
            children_pl += ',\n' + pl
            children_cats.append(ch_cat)
        if der['type'] in ('lex', 'conj'):
            der['type'] = 'lx' if der['type'] == 'lex' else der['type']
            children_cats.reverse()
            main_child_cat = next( c for c in children_cats if c != 'conj' )
            cat_pl += ', ' + main_child_cat
        pl = "{}{}({}{})".format(lvl*' ', der['type'], cat_pl, children_pl)
        return cat, pl, anno, lemma
    else:
        token, pos, ner = anno[0].split('|')
        assert der['word'] == token, "{} =\= {}".format(der['word'], token)
        kwargs = {'ind': lvl*' ',
                  'cat': cat,
                  'tok': der['word'].replace("'", r"\'"),
                  'lem': lemma[0].replace("'", r"\'").lower(),
                  'pos': pos.replace("'", r"\'"),
                  'chn': der['chunk'].replace("'", r"\'"),
                  'ner': ner.replace("'", r"\'")
                 }
        pl = "{ind}t({cat}, '{tok}', '{lem}', '{pos}', '{chn}', '{ner}')".format(**kwargs)
        return cat, pl, anno[1:], lemma[1:]


################################################################################
###################################### MAIN ####################################
################################################################################
if __name__ == '__main__':
    args = parse_arguments()
    # read derivations and annotations from files
    with open(args.der) as FDer, open(args.anno) as FAnno, open(args.lemma) as FLem:
        der_list = [ json.loads(j) for j in FDer ]
        anno_list = [ a.strip().split() for a in FAnno ]
        lemma_list = [ l.strip().split() for l in FLem ]
    assert len(der_list) == len(anno_list), "{} =\= {}".format(len(der_list), len(anno_list))
    assert len(der_list) == len(lemma_list), "{} =\= {}".format(len(der_list), len(lemma_list))
    # combine into prolog derivation
    ccg_pl = ("% this file was generated by the following command(s):"
              "\n% {}\n\n"
              ":- op(601, xfx, (/)).\n"
              ":- op(601, xfx, (\)).\n"
              ":- multifile ccg/2, id/2.\n"
              ":- discontiguous ccg/2, id/2.\n\n").format(' '.join(sys.argv))
    for i, (d, a, l) in enumerate(zip(der_list, anno_list, lemma_list), start=1):
        if args.ids and i not in args.ids: continue
        pl = derdict_anno2pl(d, a, l, v=args.v)
        ccg_pl += "ccg({},\n{}).\n\n".format(i, pl)
    with open(args.output, 'w') as O:
        O.write(ccg_pl)
